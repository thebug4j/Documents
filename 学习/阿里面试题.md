[TOC]



# 1、反向代理和负载均衡的区别

```
负载均衡：侧重于请求调度，对请求进行分发，统计服务响应时间和状态。
反向代理：侧重于对客户端提供统一的入口
```

# 2、正向代理和反向代理

```
正向代理：代理客户端向服务端发送请求，屏蔽客户端的详细 （内网出局网关）
反向代理：代理服务器接收客户端的请求，对外屏蔽服务端的架构详情
```

# 3、理解REST

```
一个url就是一个资源，所有操作都是对资源更改的角度上。CRUD(POST GET PUT DELETE)
只是理解Rest，反而不好理解，如果是站在解决url混乱的问题上，反而很快能弄懂。

```

# 4、分布式一致性理论

```
paxos、raft、zab
```

# 5、redis过期策略和内存淘汰机制

```
redis采用：定期删除+惰性删除的过期策略 + 内存淘汰机制 （注意不是采用定时删除策略）
```

# 6、redis扩容的rehash过程

```
一次性hash数据量太大、占用时间长，所以采用渐进式rehash，两个hash表。
rehashindex记录当前正在迁移的index位置，从0开始，迁移完成置为1。
rehash期间，如果有数据的增删改查：
	hash(key)<rehashindex时代表已经迁移过，到h[1]中操作，
	hash(key)>rehashindex时代表尚未进行迁移，直接在h[0]操作
	hash(key)=rehashindex时代表正在rehash。（猜测空转，等rehash过了这个index，直接操作h[1] ）
```



![img](https://img-blog.csdnimg.cn/img_convert/e10b9c0428b1eb05c0edfcbceca49c2e.png)

# 7、消息的幂等处理

```
1、查询删除天然幂等。删除返回值意义：返回影响行数n（n>=0）
2、唯一索引：唯一索引或唯一组合索引来防止新增数据存在脏数据。
3、token机制：防止页面重复提交
4、数据库更新操作加版本控制：update table set version = version+1 where version = #version# ;
5、分布式锁：redis或zookeeper
```



# 8、秒杀系统

![image-20221116112251706](/Users/thebug4j/workspace/github/Documents/学习/assets/image-20221116112251706.png)

## 1、客户端优化

### 秒杀页面

```
将秒杀页面的资源（css、js、图片、商品详情等）进行静态化，并将静态化之后的页面分发到CDN边缘节点，起到压力分散的作用。
```

### 防止提前下单

```
防止提前下单主要是在静态化页面中加入一个JS文件引用，该JS文件包含活动是否开始标记以及开始时的动态下单页面的URL参数。同时，这个JS文件是不会被CDN系统缓存的，会一直请求后端服务，所以这个JS文件一定要很小。当活动快开始的时候（比如提前），通过后台接口修改返个JS文件使之生效。
```

## 2、API接入层优化

### 限制用户维度访问频率

```
针对同一个用户（Userid 维度），做页面级删缓存，单元时间内的请求，统一走缓存，返回同一个页面。
```

### 限制商品维度访问频率

```
大量请求同时间段查询同一个商品时，可以做页面级删缓存，不管下回是谁来访问，只要是这个页面就直接返回。
```

## 3、SOA 服务层优化

```
对于后端系统的控制可以通过消息队列、异步处理、提高并发等方式解决。对于超过系统水位线的请求，直接采取「Fail-Fast」原则，拒绝掉。
```

# 9、分库分表（待补充）

事实上，MySQL单表可以存储10亿级数据，只是这时候性能比较差。**业界公认MySQL单表容量在1千万以下是最佳状态**，因为这时它的BTREE索引树高在3~5之间。

![image-20221116142206570](/Users/thebug4j/workspace/github/Documents/学习/assets/image-20221116142206570.png)

```
1千万B+树高3~5怎么算的。
mysql数据页默认16kB， 索引8B、指针6B，
第1层数据页16kB/(8B+6B) = 1140 （索引+指针）
第2层：有多少指针就有多少数据页，由1知每页可容纳1140指针，所以第2层共有指针：1140*1140 = 130万指针
第3层：有多少指针就有多少数据页，130万数据页*16KB是第三层总容量，假设mysql一条记录占1k，则可容纳130万*16条记录 = 2千万条数据

```

# 10、分布式事务

分库后需要分布式事务支持

oracle提出的XA分布式事务协议，包含2阶段提交（2pc）和3阶段提交（3pc）

![image-20221116143944634](/Users/thebug4j/workspace/github/Documents/学习/assets/image-20221116143944634.png)

# 11、一致性hash算法

```
一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环，整个哈希空间的取值范围为0~232-1。整个空间按顺时针方向组织。0~232-1在零点中方向重合。接下来使用如下算法对服务请求进行映射，将服务请求使用哈希算法算出对应的hash值，然后根据hash值的位置沿圆环顺时针查找，第一台遇到的服务器就是所对应的处理请求服务器。

好处：一致性哈希算法在1997年由麻省理工学院提出，是一种特殊的哈希算法，目的是解决分布式缓存的问题。 [1]  在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表( Distributed Hash Table，DHT) 中存在的动态伸缩等问题 [2]  。受影响的只有新增或删除的节点逆时针到上一个节点间的数据。

```

redis为什么不采用一致性hash算法：
	1. 假如node1因为热点key问题宕机了，然后选取slave1作为主节点，那么salve也会承受不了压力进而宕机。由于一致性hash算法，那么master1被剔除了，它的请求就会路由到master2，然后master2也会宕机，然后master3也会宕机，导致**缓存的雪崩效应**。
	1. 采用hash算法，master3因为热点key宕机掉了也只会影响0-6000的key的访问。而且运维人员可以手动处理故障，将**热点的卡槽分配到性能更好的机器上**。（redis采用将槽分配个新的节点进行横向扩容）



![image-20221116154819485](/Users/thebug4j/workspace/github/Documents/学习/assets/image-20221116154819485.png)

# 12 聚集索引

1、**聚簇索引的顺序就是数据的物理存储顺序**，而对非聚簇索引的解释是:索引顺序与数据物理排列顺序无关。正是因为如此，所以一个表最多只能有一个聚簇索引。

我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。

InnoDB只聚集在同一页面中的记录，包含相邻键值的页面可能相距很远



**从客观规律往下理解，从概念往实现理解，因为先有概念才有实现，不要从实现往概念理解，实现限于条件，偶尔会做出妥协。**

1、聚簇索引的顺序就是数据的物理存储顺序 理解：数据（索引+数据）紧密聚集在一块，在连续磁盘上聚集。所以聚集索引的顺序就是数据物理存储顺序。这样设计的目的，取数时就可以磁盘顺序读取，效率最高。

2、但是实现上很难，除非数据是一次性的存储，且后续不会增删改。而这个对关系型数据库不现实。

3、mysql innodb的做法是在聚集和数据变动二者间做了平衡，分页，默认16kb为一页，这样内存按页加载数据，相关的数据一起加载到内存，对于顺序相关的范围查询很友好。而增删改时，以页为单位进行。不会破坏局部有序性。且B+树叶子节点间串联成链表，对查询销量也不会太过影响。